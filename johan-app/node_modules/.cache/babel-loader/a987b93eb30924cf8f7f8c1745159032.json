{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst filter_1 = require(\"./filter\");\n\nconst constants_1 = require(\"./constants\");\n\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n  constructor(options, callStream) {\n    super();\n    this.options = options;\n    this.callStream = callStream;\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n\n  async sendMessage(message) {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxSendMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n\n      if (concreteMessage.message.length > this.maxSendMessageSize) {\n        this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);\n        return Promise.reject('Message too large');\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n\n  async receiveMessage(message) {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxReceiveMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n\n      if (concreteMessage.length > this.maxReceiveMessageSize) {\n        this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);\n        return Promise.reject('Message too large');\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n\n}\n\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\n\nclass MaxMessageSizeFilterFactory {\n  constructor(options) {\n    this.options = options;\n  }\n\n  createFilter(callStream) {\n    return new MaxMessageSizeFilter(this.options, callStream);\n  }\n\n}\n\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;","map":{"version":3,"sources":["../../src/max-message-size-filter.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAiBA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAOA,MAAa,oBAAb,SAA0C,QAAA,CAAA,UAA1C,CAAoD;AAGlD,EAAA,WAAA,CACmB,OADnB,EAEmB,UAFnB,EAEmC;AAEjC;AAHiB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,UAAA,GAAA,UAAA;AAJX,SAAA,kBAAA,GAA6B,WAAA,CAAA,+BAA7B;AACA,SAAA,qBAAA,GAAgC,WAAA,CAAA,kCAAhC;;AAMN,QAAI,kCAAkC,OAAtC,EAA+C;AAC7C,WAAK,kBAAL,GAA0B,OAAO,CAAC,8BAAD,CAAjC;AACD;;AACD,QAAI,qCAAqC,OAAzC,EAAkD;AAChD,WAAK,qBAAL,GAA6B,OAAO,CAAC,iCAAD,CAApC;AACD;AACF;;AAED,QAAM,WAAN,CAAkB,OAAlB,EAA+C;AAC7C;;AAEA,QAAI,KAAK,kBAAL,KAA4B,CAAC,CAAjC,EAAoC;AAClC,aAAO,OAAP;AACD,KAFD,MAEO;AACL,YAAM,eAAe,GAAG,MAAM,OAA9B;;AACA,UAAI,eAAe,CAAC,OAAhB,CAAwB,MAAxB,GAAiC,KAAK,kBAA1C,EAA8D;AAC5D,aAAK,UAAL,CAAgB,gBAAhB,CACE,WAAA,CAAA,MAAA,CAAO,kBADT,EAEE,iCAAiC,eAAe,CAAC,OAAhB,CAAwB,MAAM,QAAQ,KAAK,kBAAkB,GAFhG;AAIA,eAAO,OAAO,CAAC,MAAR,CAA4B,mBAA5B,CAAP;AACD,OAND,MAMO;AACL,eAAO,eAAP;AACD;AACF;AACF;;AAED,QAAM,cAAN,CAAqB,OAArB,EAA6C;AAC3C;;AAEA,QAAI,KAAK,qBAAL,KAA+B,CAAC,CAApC,EAAuC;AACrC,aAAO,OAAP;AACD,KAFD,MAEO;AACL,YAAM,eAAe,GAAG,MAAM,OAA9B;;AACA,UAAI,eAAe,CAAC,MAAhB,GAAyB,KAAK,qBAAlC,EAAyD;AACvD,aAAK,UAAL,CAAgB,gBAAhB,CACE,WAAA,CAAA,MAAA,CAAO,kBADT,EAEE,qCAAqC,eAAe,CAAC,MAAM,QAAQ,KAAK,qBAAqB,GAF/F;AAIA,eAAO,OAAO,CAAC,MAAR,CAAuB,mBAAvB,CAAP;AACD,OAND,MAMO;AACL,eAAO,eAAP;AACD;AACF;AACF;;AApDiD;;AAApD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAuDA,MAAa,2BAAb,CAAwC;AAEtC,EAAA,WAAA,CAA6B,OAA7B,EAAoD;AAAvB,SAAA,OAAA,GAAA,OAAA;AAA2B;;AAExD,EAAA,YAAY,CAAC,UAAD,EAAiB;AAC3B,WAAO,IAAI,oBAAJ,CAAyB,KAAK,OAA9B,EAAuC,UAAvC,CAAP;AACD;;AANqC;;AAAxC,OAAA,CAAA,2BAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst filter_1 = require(\"./filter\");\nconst constants_1 = require(\"./constants\");\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n    constructor(options, callStream) {\n        super();\n        this.options = options;\n        this.callStream = callStream;\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n    }\n    async sendMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */\n        if (this.maxSendMessageSize === -1) {\n            return message;\n        }\n        else {\n            const concreteMessage = await message;\n            if (concreteMessage.message.length > this.maxSendMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);\n                return Promise.reject('Message too large');\n            }\n            else {\n                return concreteMessage;\n            }\n        }\n    }\n    async receiveMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */\n        if (this.maxReceiveMessageSize === -1) {\n            return message;\n        }\n        else {\n            const concreteMessage = await message;\n            if (concreteMessage.length > this.maxReceiveMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);\n                return Promise.reject('Message too large');\n            }\n            else {\n                return concreteMessage;\n            }\n        }\n    }\n}\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\nclass MaxMessageSizeFilterFactory {\n    constructor(options) {\n        this.options = options;\n    }\n    createFilter(callStream) {\n        return new MaxMessageSizeFilter(this.options, callStream);\n    }\n}\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;\n//# sourceMappingURL=max-message-size-filter.js.map"]},"metadata":{},"sourceType":"script"}