/**
 * ranges-push
 * Manage the array of ranges referencing the index ranges within the string
 * Version: 3.7.4
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/ranges-push
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).rangesPush=t()}(this,(function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function r(e){return function(e){if(Array.isArray(e))return n(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return n(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(r);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return n(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function n(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function s(e,t=!0,r){if(!(r.trim().length||e.length&&"\n"!==r&&" "!==r&&" "===(t?e[e.length-1]:e[0])||e.length&&"\n"===(t?e[e.length-1]:e[0])&&"\n"!==r&&" "!==r))if(t){if(("\n"===r||" "===r)&&e.length&&" "===e[e.length-1])for(;e.length&&" "===e[e.length-1];)e.pop();e.push(" "===r||"\n"===r?r:" ")}else{if(("\n"===r||" "===r)&&e.length&&" "===e[0])for(;e.length&&" "===e[0];)e.shift();e.unshift(" "===r||"\n"===r?r:" ")}}function i(e,t){if("string"==typeof e&&e.length){let r,n,i=!1;if(e.includes("\r\n")&&(i=!0),r=t&&"number"==typeof t?t:1,""===e.trim()){const t=[];for(n=r,Array.from(e).forEach(e=>{("\n"!==e||n)&&("\n"===e&&n--,s(t,!0,e))});t.length>1&&" "===t[t.length-1];)t.pop();return t.join("")}const o=[];if(n=r,""===e[0].trim())for(let t=0,r=e.length;t<r&&0===e[t].trim().length;t++)("\n"!==e[t]||n)&&("\n"===e[t]&&n--,s(o,!0,e[t]));const a=[];if(n=r,""===e.slice(-1).trim())for(let t=e.length;t--&&0===e[t].trim().length;)("\n"!==e[t]||n)&&("\n"===e[t]&&n--,s(a,!1,e[t]));return i?`${o.join("")}${e.trim()}${a.join("")}`.replace(/\n/g,"\r\n"):o.join("")+e.trim()+a.join("")}return e}function o(e,t){if(!Array.isArray(e))throw new TypeError(`ranges-sort: [THROW_ID_01] Input must be an array, consisting of range arrays! Currently its type is: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(0===e.length)return e;const r=Object.assign({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null},t);let n,s;if(r.strictlyTwoElementsInRangeArrays&&!e.every((e,t)=>2===e.length||(n=t,s=e.length,!1)))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) has not two but ${s} elements!`);if(!e.every((e,t)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(n=t,!1)))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) does not consist of only natural numbers!`);const i=e.length*e.length;let o=0;return Array.from(e).sort((e,t)=>(r.progressFn&&(o++,r.progressFn(Math.floor(100*o/i))),e[0]===t[0]?e[1]<t[1]?-1:e[1]>t[1]?1:0:e[0]<t[0]?-1:1))}function a(e){return null!=e}function l(e){return Number.isInteger(e)&&e>=0}function u(e){return"string"==typeof e}function g(e){return/^\d*$/.test(e)?parseInt(e,10):e}return function(){function n(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n);var r=Object.assign({},{limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},t);if(r.mergeType&&1!==r.mergeType&&2!==r.mergeType)if(u(r.mergeType)&&"1"===r.mergeType.trim())r.mergeType=1;else{if(!u(r.mergeType)||"2"!==r.mergeType.trim())throw new Error('ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(e(r.mergeType),'", equal to ').concat(JSON.stringify(r.mergeType,null,4)));r.mergeType=2}this.opts=r}var s,f,h;return s=n,(f=[{key:"add",value:function(t,n,s){for(var o=this,f=arguments.length,h=new Array(f>3?f-3:0),y=3;y<f;y++)h[y-3]=arguments[y];if(h.length>0)throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_03] Please don't overload the add() method. From the 4th input argument onwards we see these redundant arguments: ".concat(JSON.stringify(h,null,4)));if(a(t)||a(n)){if(a(t)&&!a(n)){if(Array.isArray(t)){if(t.length){if(t.some((function(e){return Array.isArray(e)})))return void t.forEach((function(e){Array.isArray(e)&&o.add.apply(o,r(e))}));t.length>1&&l(g(t[0]))&&l(g(t[1]))&&this.add.apply(this,r(t))}return}throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set ('.concat(JSON.stringify(t,null,0),') but second-one, "to" is not (').concat(JSON.stringify(n,null,0),")"))}if(!a(t)&&a(n))throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set ('.concat(JSON.stringify(n,null,0),') but first-one, "from" is not (').concat(JSON.stringify(t,null,0),")"));var p=/^\d*$/.test(t)?parseInt(t,10):t,c=/^\d*$/.test(n)?parseInt(n,10):n;if(l(s)&&(s=String(s)),!l(p)||!l(c))throw l(p)&&p>=0?new TypeError('ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(e(c),'" equal to: ').concat(JSON.stringify(c,null,4))):new TypeError('ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(e(p),'" equal to: ').concat(JSON.stringify(p,null,4)));if(a(s)&&!u(s)&&!l(s))throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ".concat(e(s),", equal to:\n").concat(JSON.stringify(s,null,4)));if(a(this.slices)&&Array.isArray(this.last())&&p===this.last()[1]){if(this.last()[1]=c,this.last()[2],null!==this.last()[2]&&a(s)){var m=!(a(this.last()[2])&&this.last()[2].length>0)||this.opts&&this.opts.mergeType&&1!==this.opts.mergeType?s:this.last()[2]+s;this.opts.limitToBeAddedWhitespace&&(m=i(m,this.opts.limitLinebreaksCount)),u(m)&&!m.length||(this.last()[2]=m)}}else{this.slices||(this.slices=[]);var d=void 0===s||u(s)&&!s.length?[p,c]:[p,c,this.opts.limitToBeAddedWhitespace?i(s,this.opts.limitLinebreaksCount):s];this.slices.push(d)}}}},{key:"push",value:function(e,t,r){for(var n=arguments.length,s=new Array(n>3?n-3:0),i=3;i<n;i++)s[i-3]=arguments[i];this.add.apply(this,[e,t,r].concat(s))}},{key:"current",value:function(){var e=this;return null!=this.slices?(this.slices=function(e,t){function r(e){return"string"==typeof e}function n(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e))return e;const s={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};let i;if(t){if(!n(t))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(t,null,4)} (type ${typeof t})`);if(i=Object.assign({},s,t),i.progressFn&&n(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&"function"!=typeof i.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof i.progressFn}", equal to ${JSON.stringify(i.progressFn,null,4)}`);if(i.mergeType&&1!==i.mergeType&&2!==i.mergeType)if(r(i.mergeType)&&"1"===i.mergeType.trim())i.mergeType=1;else{if(!r(i.mergeType)||"2"!==i.mergeType.trim())throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof i.mergeType}", equal to ${JSON.stringify(i.mergeType,null,4)}`);i.mergeType=2}if("boolean"!=typeof i.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof i.joinRangesThatTouchEdges}", equal to ${JSON.stringify(i.joinRangesThatTouchEdges,null,4)}`)}else i=Object.assign({},s);const a=e.map(e=>[...e]).filter(e=>void 0!==e[2]||e[0]!==e[1]);let l,u,g;l=i.progressFn?o(a,{progressFn:e=>{g=Math.floor(e/5),g!==u&&(u=g,i.progressFn(g))}}):o(a);const f=l.length-1;for(let e=f;e>0;e--)i.progressFn&&(g=Math.floor(78*(1-e/f))+21,g!==u&&g>u&&(u=g,i.progressFn(g))),(l[e][0]<=l[e-1][0]||!i.joinRangesThatTouchEdges&&l[e][0]<l[e-1][1]||i.joinRangesThatTouchEdges&&l[e][0]<=l[e-1][1])&&(l[e-1][0]=Math.min(l[e][0],l[e-1][0]),l[e-1][1]=Math.max(l[e][1],l[e-1][1]),void 0!==l[e][2]&&(l[e-1][0]>=l[e][0]||l[e-1][1]<=l[e][1])&&null!==l[e-1][2]&&(null===l[e][2]&&null!==l[e-1][2]?l[e-1][2]=null:void 0!==l[e-1][2]?2===i.mergeType&&l[e-1][0]===l[e][0]?l[e-1][2]=l[e][2]:l[e-1][2]+=l[e][2]:l[e-1][2]=l[e][2]),l.splice(e,1),e=l.length);return l}(this.slices,{mergeType:this.opts.mergeType}),this.opts.limitToBeAddedWhitespace?this.slices.map((function(t){return a(t[2])?[t[0],t[1],i(t[2],e.opts.limitLinebreaksCount)]:t})):this.slices):null}},{key:"wipe",value:function(){this.slices=void 0}},{key:"replace",value:function(e){if(Array.isArray(e)&&e.length){if(!Array.isArray(e[0])||!l(e[0][0]))throw new Error("ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ".concat(JSON.stringify(e[0],null,4)," should be an array and its first element should be an integer, a string index."));this.slices=Array.from(e)}else this.slices=void 0}},{key:"last",value:function(){return void 0!==this.slices&&Array.isArray(this.slices)?this.slices[this.slices.length-1]:null}}])&&t(s.prototype,f),h&&t(s,h),n}()}));
